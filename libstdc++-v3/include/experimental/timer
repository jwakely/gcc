// <experimental/timer> -*- C++ -*-

// Copyright (C) 2015 Free Software Foundation, Inc.
//
// This file is part of the GNU ISO C++ Library.  This library is free
// software; you can redistribute it and/or modify it under the
// terms of the GNU General Public License as published by the
// Free Software Foundation; either version 3, or (at your option)
// any later version.

// This library is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// Under Section 7 of GPL version 3, you are granted additional
// permissions described in the GCC Runtime Library Exception, version
// 3.1, as published by the Free Software Foundation.

// You should have received a copy of the GNU General Public License and
// a copy of the GCC Runtime Library Exception along with this program;
// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
// <http://www.gnu.org/licenses/>.

/** @file experimental/timer
 *  This is a TS C++ Library header.
 */

#ifndef _GLIBCXX_EXPERIMENTAL_TIMER
#define _GLIBCXX_EXPERIMENTAL_TIMER 1

#pragma GCC system_header

#if __cplusplus < 201402L
# include <bits/c++14_warning.h>
#else

#include <chrono>
#include <system_error>
#include <thread>
#include <experimental/netfwd>
#include <experimental/io_context>
#include <experimental/bits/net.h>

namespace std _GLIBCXX_VISIBILITY(default)
{
namespace experimental
{
namespace net
{
inline namespace v1
{
_GLIBCXX_BEGIN_NAMESPACE_VERSION

  /**
   * @ingroup networking
   * @{
   */

  template<typename _Clock>
    struct wait_traits
    {
      static typename _Clock::duration
      to_wait_duration(const typename _Clock::duration& __d)
      { return __d; }

      static typename _Clock::duration
      to_wait_duration(const typename _Clock::time_point& __t)
      {
	auto __now = _Clock::now();
	if ((__now + _Clock::duration::max()) < __t) // TODO overflow!
	  return _Clock::duration::max();
	if ((__now + _Clock::duration::min()) > __t)
	  return _Clock::duration::min();
	return __t - __now;
      }
    };

  template<typename _Clock, typename _WaitTraits>
    class basic_waitable_timer
    {
    public:
      // types:

      typedef io_context::executor_type executor_type;
      typedef _Clock clock_type;
      typedef typename clock_type::duration duration;
      typedef typename clock_type::time_point time_point;
      typedef _WaitTraits traits_type;

      // construct / copy / destroy:

      explicit
      basic_waitable_timer(io_context& __ctx)
      : _M_ex(__ctx.get_executor()), _M_expiry()
      { }

      basic_waitable_timer(io_context& __ctx, const time_point& __t)
      : _M_ex(__ctx.get_executor()), _M_expiry(__t)
      { }

      basic_waitable_timer(io_context& __ctx, const duration& __d)
      : _M_ex(__ctx.get_executor()), _M_expiry(_Clock::now() + __d)
      { }

      basic_waitable_timer(const basic_waitable_timer&) = delete;

      basic_waitable_timer(basic_waitable_timer&& __rhs)
      : _M_ex(std::move(__rhs._M_ex)), _M_expiry(__rhs._M_expiry)
      {
	_M_waiters.swap(__rhs._M_waiters);
	__rhs._M_expiry = time_point{};
	__rhs.cancel();
      }

      ~basic_waitable_timer() { cancel(); }

      basic_waitable_timer& operator=(const basic_waitable_timer&) = delete;

      basic_waitable_timer&
      operator=(basic_waitable_timer&& __rhs)
      {
	if (this == std::addressof(__rhs))
	  return *this;
	cancel();
	_M_ex = std::move(__rhs._M_ex);
	_M_expiry = __rhs._M_expiry;
	__rhs._M_expiry = time_point{};
	_M_waiters->splice(_M_waiters->begin(), *__rhs._M_waiters);
	return *this;
      }

      // basic_waitable_timer operations:

      executor_type get_executor() noexcept { return _M_ex; }

      size_t cancel();
      size_t cancel_one();

      time_point expiry() const { return _M_expiry; }
      size_t expires_at(const time_point& __t)
      {
	size_t __cancelled = cancel();
	_M_expiry = __t;
	return __cancelled;
      }

      size_t expires_after(const duration& __d)
      { return expires_at(_Clock::now() + __d); }

      void wait();
      void wait(error_code& __ec);

      template<typename _CompletionToken>
	__deduced_t<_CompletionToken, void(error_code)>
	async_wait(_CompletionToken&& __token);

    private:
      struct __waiter
      {
	explicit
	__waiter(shared_ptr<atomic_int> __flag) : _M_flag(std::move(__flag))
	{ }

	__waiter(__waiter&& __other) noexcept
	: _M_flag(std::move(__other._M_flag))
	{ }

	~__waiter() { if (_M_flag) _M_finished(); }

	void _M_finished() { *_M_flag = 2; _M_flag = nullptr; }

	bool _M_cancelled() const { return *_M_flag == 1; }

      private:
	shared_ptr<atomic_int> _M_flag;
      };

      __waiter
      _M_new_waiter()
      {
	for (auto __it = _M_waiters->begin(), __end = _M_waiters->end();
	    __it != __end; ++__it)
	  if (*__it > 1)
	    {
	      _M_waiters->splice(_M_waiters->end(), *_M_waiters, __it);
	      *__it = 0;
	      return __waiter( { _M_waiters, &*__it } );
	    }
	_M_waiters->emplace_back(0);
	return __waiter( { _M_waiters, &_M_waiters->back() } );
      }

      time_point _M_expiry;
      executor_type _M_ex;
      shared_ptr<list<atomic_int>> _M_waiters{make_shared<list<atomic_int>>()};
    };

  typedef basic_waitable_timer<chrono::system_clock> system_timer;
  typedef basic_waitable_timer<chrono::steady_clock> steady_timer;
  typedef basic_waitable_timer<chrono::high_resolution_clock>
    high_resolution_timer;

  template<typename _Clock, typename _WaitTraits>
    size_t
    basic_waitable_timer<_Clock, _WaitTraits>::cancel()
    {
      size_t __cancelled = 0;
      for (auto& __x : *_M_waiters)
	if (__x == 0 && ++__x == 1)
	  ++__cancelled;
      return __cancelled;
    }

  template<typename _Clock, typename _WaitTraits>
    size_t
    basic_waitable_timer<_Clock, _WaitTraits>::cancel_one()
    {
      for (auto& __x : *_M_waiters)
	if (__x == 0 && ++__x == 1)
	  return 1;
      return 0;
    }

  template<typename _Clock, typename _WaitTraits>
    void
    basic_waitable_timer<_Clock, _WaitTraits>::wait()
    {
      _M_ex.dispatch([this] {
	  while (clock_type::now() < _M_expiry)
	    this_thread::sleep_for(traits_type::to_wait_duration(_M_expiry));
      }, allocator<void>{});
    }

  template<typename _Clock, typename _WaitTraits>
    void
    basic_waitable_timer<_Clock, _WaitTraits>::wait(error_code&)
    {
      _M_ex.dispatch([this] {
	  while (clock_type::now() < _M_expiry)
	    this_thread::sleep_for(traits_type::to_wait_duration(_M_expiry));
      }, _M_waiters->get_allocator());
    }

  template<typename _Clock, typename _WaitTraits>
  template<typename _CompletionToken>
    __deduced_t<_CompletionToken, void(error_code)>
    basic_waitable_timer<_Clock, _WaitTraits>::
    async_wait(_CompletionToken&& __token)
    {
      using _Signature = void(error_code);

      auto __work1 = net::make_work_guard(_M_ex);

      async_completion<_CompletionToken, _Signature> __init(__token);

      auto __work2 = net::get_associated_executor(__init.completion_handler,
						  _M_ex);

      _M_ex.post([__status = _M_new_waiter(),
		  __h = std::move(__init.completion_handler),
                  __expiry = _M_expiry]() mutable {
	  error_code __ec;
	  auto __now = clock_type::now();
	  while (!__status._M_cancelled() && __now < __expiry)
	    {
	      // TODO query io_context for next expiry to find __e
	      auto __e = std::min(__now + duration(5), __expiry);
	      this_thread::sleep_for(traits_type::to_wait_duration(__e));
	      __now = clock_type::now();
	    }
	  if (__status._M_cancelled())
	    __ec = std::make_error_code(errc::operation_canceled);
	  __status._M_finished();
	  __h(__ec);
      }, _M_waiters->get_allocator());
      return __init.result.get();
    }

  /// @}

_GLIBCXX_END_NAMESPACE_VERSION
} // namespace v1
} // namespace net
} // namespace experimental
} // namespace std

#endif // C++14

#endif // _GLIBCXX_EXPERIMENTAL_TIMER
